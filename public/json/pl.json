{
  "1":{
    "1":{
        "chapterName": "Why Predicates?",
        "chapterNum": "1",
        "chapterDescription": "This chapter introduces a logical language called PL. It is a version of predicate Logic, because it introduces words like all and some, which tell us about quantities. As its name implies, the basic units of the language are predicates and terms.",
        "title":"From Sentences to Predicates",


        "content":[
          {
            "type":"p",
            "substance":[

              "Consider the following argument, which is obviously valid in English:"




            ]
          },
          {
            "type":"unorderedList",
            "substance":[  "If everyone knows logic, then either no one will be confused or everyone will. Everyone will be confused only if we try to believe a contradiction. Everyone knows logic."]
          },
          {
            "type":"p",
            "substance":[
              "In order to symbolize this in SL, we will need a symbolization key. "
            ]
          },
          {
            "type":"symbolkey",
            "key":[

                ["L","Everyone knows logic."]
              ,

                ["N","No one will be confused."]
              ,
                ["E","Everyone will be confused."]
              ,

              ["B","We try to believe a contradiction."]


            ]

          },{
            "type":"p",
            "substance":[
              "Notice that $N$ and $E$ are both about people being confused, but they are two separate sentence letters. We could not replace $E$ with $\\neg N$. Why not? $\\neg N$ means 'It is not the case that no one will be confused.' This would be the case if even one person were confused, so it is a long way from saying that everyone will be confused.",
              "Once we have separate sentence letters for $N$ and $E$, however, we erase any connection between the two. They are just two atomic sentences which might be true or false independently. In English, it could never be the case that both no one and everyone was confused. As sentences of SL, however, there is a truth value assignment for which $N$ and $E$ are both true.",
              "Expressions like 'no one', 'everyone', and 'anyone' are called quantifiers. By translating $N$ and $E$ as separate atomic sentences, we leave out the quantifier structure of the sentences. Fortunately, the quantifier structure is not what makes this argument valid. As such, we can safely ignore it. To see this, we translate the argument to SL:"
            ]
          },
          {
            "type":"arg",
            "premises":[

            "$L \\to (N \\vee E)$",
              "$E \\to B$",
            "$L$"



          ],
          "conclusion":"$\\neg B \\to N$"

          },
          {
            "type": "p",
            "substance":[
              "This is a valid argument in SL. (You can do a truth table to check this.) ",
              "Now consider another argument. This one is also valid in English.",
              "$$\\text{Willard is a logician. All logicians wear funny hats. Therefore, Willard wears a funny hat.}$$",
              "Using obvious symbolization keys, we translate this argument like so:"
            ]
          },
          {
            "type":"arg",
            "premises":[

            "$W$",

            "$A$"



          ],
          "conclusion":"$F$"

          },
          {
            "type":"p",
            "substance":[
              "This is invalid in SL. (Again, you can confirm this with a truth table.) There is something very wrong here, because this is clearly a valid argument in English. The symbolization in SL leaves out all the important structure. Once again, the translation to SL overlooks quantifier structure: The sentence 'All logicians wear funny hats' is about both logicians and hat-wearing. By not translating this structure, we lose the connection between Willard's being a logician and Willard's wearing a hat.",

              "Some arguments with quantifier structure can be captured in SL, like the first example, even though SL ignores the quantifier structure. Other arguments are completely botched in SL, like the second example. Notice that the problem is not that we have made a mistake while symbolizing the second argument. These are the best symbolizations we can give for these arguments in SL."

            ]
          },
          {
            "type":"textInput","eventId":"pl-1-1","substance":["Is that really the best SL translation we can come up with? If $P_2$ is construed as 'If someone is a logician, then she wears a funny hat', would the argument be valid in SL?"]
          },
          {
            "type":"p",
            "substance":[


              "Generally, if an argument containing quantifiers comes out valid in SL, then the English language argument is valid. If it comes out invalid in SL, then we cannot say the English language argument is invalid. The argument might be valid because of quantifier structure which the natural language argument has and which the argument in SL lacks.",

              "Similarly, if a sentence with quantifiers comes out as a tautology in SL, then the English sentence is logically true. If comes out as contingent in SL, then this might be because of the structure of the quantifiers that gets removed when we translate into the formal language.",

              "In order to symbolize arguments that rely on quantifier structure, we need to develop a different logical language. We will call this language predicate Logic, PL."
            ]
          }
        ]
      },
      "2":{
        "title": "Building Blocks of Predicate Logic",
        "content":
        [

          {
            "type":"ps",
            "substance":[
              "Just as sentences were the basic unit of sentential logic, predicates will be the basic unit of predicate logic. A predicate is an expression like 'is a dog.' This is not a sentence on its own. It is neither true nor false. In order to be true or false, we need to specify something: Who or what is it that is a dog?",

              "The details of this will be explained in the rest of the chapter, but here is the basic idea: In PL, we will represent predicates with capital letters. For instance, we might let $D$ stand for '_ is a dog.' We will use lower-case letters as the names of specific things. For instance, we might let $b$ stand for Bertie. The expression $Db$ will be a sentence in PL. It is a translation of the sentence 'Bertie is a dog.'",

              "In order to represent quantifier structure, we will also have symbols that represent quantifiers. For instance, '$\\exists$' will mean 'There is some_.' So to say that there is a dog, we can write $\\exists x Dx$; that is: There is some $x$ such that $x$ is a dog.",

              "That will come later. We start by defining singular terms and predicates.",

              "<h3>Singular Terms</h3>",

              "In English, a singular term is a word or phrase that refers to a specific person, place, or thing. The word 'dog' is not a singular term, because there are a great many dogs. The phrase 'Philip's dog Bertie' is a singular term, because it refers to a specific little terrier.",

              "A proper name is a singular term that picks out an individual without describing it. The name 'Emerson' is a proper name, and the name alone does not tell you anything about Emerson. Of course, some names are traditionally given to boys and other are traditionally given to girls. If 'Jack Hathaway' is used as a singular term, you might guess that it refers to a man. However, the name does not necessarily mean that the person referred to is a man---or even that the creature referred to is a person. Jack might be a giraffe for all you could tell just from the name. There is a great deal of philosophical action surrounding this issue, but the important point here is that a name is a singular term because it picks out a single, specific individual.",

              "Other singular terms more obviously convey information about the thing to which they refer. For instance, you can tell without being told anything further that 'Philip's dog Bertie' is a singular term that refers to a dog. A definite description picks out an individual by means of a unique description. In English, definite descriptions are often phrases of the form 'the such-and-so.' They refer to the specific thing that matches the given description. For example, 'the tallest member of Monty Python' and 'the first emperor of China' are definite descriptions. A description that does not pick out a specific individual is not a definite description. 'A member of Monty Python' and 'an emperor of China' are not definite descriptions.",

              "We can use proper names and definite descriptions to pick out the same thing. The proper name 'Mount Rainier' names the location picked out by the definite description 'the highest peak in Washington state.' The expressions refer to the same place in different ways. You learn nothing from my saying that I am going to Mount Rainier, unless you already know some geography. You could guess that it is a mountain, perhaps, but even this is not a sure thing; for all you know it might be a college, like Mount Holyoke. Yet if I were to say that I was going to the highest peak in Washington state, you would know immediately that I was going to a mountain in Washington state.",

              "In English, the specification of a singular term may depend on context; 'Willard' means a specific person and not just someone named Willard; 'P.D. Magnus' as a logical singular term means me and not the other P.D. Magnus. We live with this kind of ambiguity in English, but it is important to keep in mind that singular terms in PL must refer to just one specific thing.",

              "In PL, we will symbolize singular terms with lower-case letters $a$ through $w$. We can add subscripts if we want to use some letter more than once. So $a,b,c,... w, a_1, f_{32}, j_{390}$, and $m_{12}$ are all terms in PL.",

              "Singular terms are called constants because they pick out specific individuals. Note that $x, y$, and $z$ are not constants in PL. They will be variables, letters which do not stand for any specific thing. We will need them when we introduce quantifiers.",

              "<h3>Predicates</h3>",

              "The simplest predicates are properties of individuals. They are things you can say about an object. '_ is a dog' and '_ is a member of Monty Python' are both predicates. In translating English sentences, the term will not always come at the beginning of the sentence: 'A piano fell on _' is also a predicate. Predicates like these are called one-place or monadic, because there is only one blank to fill in. A one-place predicate and a singular term combine to make a sentence.",

              "Other predicates are about the relation between two things. For instance, '_ is bigger than _', '_ is to the left of _', and '_ owes money to _.' These are two-place or dyadic predicates, because they need to be filled in with two terms in order to make a sentence.",

              "In general, you can think about predicates as schematic sentences that need to be filled out with some number of terms. Conversely, you can start with sentences and make predicates out of them by removing terms. Consider the sentence, 'Vinnie borrowed the family car from Nunzio.' By removing a singular term, we can recognize this sentence as using any of three different monadic predicates:"
            ]
          },
          {
            "type":"unorderedList",
            "substance":[
               "_ borrowed the family car from Numzio.",
              "Vinnie borrowed _ from Nunzio.",
              "Vinnie borrowed the family car from _."
            ]
          },
          {
            "type":"p",
            "substance":[
              "By removing two singular terms, we can recognize three different dyadic predicates:"
            ]
          },
          {
            "type":"unorderedList",
            "substance":[
               "_ borrowed the family car from _.",
              "Vinnie borrowed _ from _.",
               "Vinnie borrowed the _ from _."
            ]
          },
          {
            "type":"p",
            "substance":[
              "By removing all three singular terms, we can recognize one three-place or triadic predicate:"
            ]
          },
          {
            "type":"unorderedList",
            "substance":[
               "_ borrowed _ from _."
            ]
          },

          {
            "type":"p",
            "substance":[
              "If we are translating this sentence into PL, should we translate it with a one-, two-, or three-place predicate? It depends on what we want to be able to say. If the only thing that we will discuss being borrowed is the family car, then the generality of the three-place predicate is unnecessary. If the only borrowing we need to symbolize is different people borrowing the family car from Nunzio, then a one-place predicate will be enough.",

              "In general, we can have predicates with as many places as we need. Predicates with more than one place are called polyadic. Predicates with $n$ places, for some number $n$, are called n-place or n-adic.",

              "In PL, we symbolize predicates with capital letters $A$ through $Z$, with or without subscripts. When we give a symbolization key for predicates, we will not use blanks; instead, we will use variables. By convention, constants are listed at the end of the key. So we might write a key that looks like this:"
            ]
          },

          {
            "type":"symbolkey",
            "key":[
              ["$Ax$", "x is angry."],
              ["$Hx$","x is happy."],
              ["$Txy$","x is as taller than y."],
              ["$a$", "Alex"],
              ["$b$", "Bob"]
            ]
          },
          {
            "type":"p",
            "substance":[
              "We can symbolize sentences that use any combination of these predicates and terms. For example:"
            ]
          },
          {
            "type":"unorderedList",
            "substance":[
               "Bob is angry.","Alex is happy","If Bob is angry, Alex is happy.", "If Alex is taller than Bob, then Bob is angry."
            ]
          },
          {
            "type":"p",
            "substance":[
              "For the following reading exercise, use the following symbolization key:"
            ]
          },
          {
            "type":"symbolkey",
            "key":[
              ["$Fxy$", "x is a friend of y."],
              ["$Sxy$","x is shorter than y."],
              ["$Ax$","x is an adult."],
              ["$Cx$", "x is a child."],
              ["$j$", "Joey"],
              ["$r$","Rob"],
              ["$c$","Caroline"]
            ]
          },
          {"type":"matching",
            "instruction": "Match the following translations by dragging the corresponding PL sentence.",
          "eventId":"pl-1-matching"},
          {"type":"ps",
          "substance":[
            "<h3>Quantifiers</h3>",
            "We are now ready to introduce quantifiers. Consider these sentences:"
            ]},
            {
              "type":"unorderedList",
              "substance":[
                 "Everyone is an adult.","Everyone is at least as short as Rob","Someone is child."

              ]
            },
            {"type":"ps",
            "substance":[
              "It might be tempting to translate the first sentence as $Hd \\wedge Hg \\wedge Hm$. Yet this would only say that Donald, Gregor, and Marybeth are happy. We want to say that everyone is happy, even if we have not defined a constant to name them. In order to do this, we introduce the $\\forall$ symbol. This is called the universal quantifier.",
              "A quantifier must always be followed by a variable and a formula that includes that variable. We can translate the first sentence as $\\forall x Hx$. Paraphrased in English, this means 'For all $x$, $x$ is happy.' The formula that follows the quantifier is called the scope of the quantifier. We will give a formal definition of scope later, but intuitively it is the part of the sentence that the quantifier quantifies over. In $\\forall x Hx$, the scope of the universal quantifier is $Hx$.",
              "The sentence 'Everyone is at least as short as Rob' can be paraphrased as, 'For all $x$, $x$ is not shorter than Rob.' This translates as $\\forall x \\neg Sxr$.",
              "In these quantified sentences, the variable $x$ is serving as a kind of placeholder. The expression $\\forall x$ means that you can pick anyone and put them in as $x$. There is no special reason to use $x$ rather than some other variable. The sentence $\\forall x Hx$ means exactly the same thing as $\\forall y Hy$, $\\forall z Hz$, and $\\forall x_5 Hx_5$.",
              "To translate 'someone is a child', we introduce another new symbol: the existential quantifier, $\\exists$. Like the universal quantifier, the existential quantifier requires a variable. The sentence can be translated as $\\exists x Cx$. This means that there is some $x$ which is a child. More precisely, it means that there is at least one child. Once again, the variable is a kind of placeholder; we could just as easily have translated the sentence as $\\exists z Az$.",
              "Now consider these sentences:"
              ]},
              {
                "type":"unorderedList",
                "substance":[
                   "No one is angry.","There is someone who is not happy.","Not everyone is happy."
                ]
              },
              {"type":"ps",
              "substance":[
                "The first sentence can be paraphrased as, 'It is not the case that someone is angry.' This can be translated using negation and an existential quantifier: $\\neg \\exists x Ax$. Yet it could also be paraphrased as, 'Everyone is not angry.' With this in mind, it can be translated using negation and a universal quantifier: $\\forall x \\neg Ax$. Both of these are acceptable translations, because they are logically equivalent. The critical thing is whether the negation comes before or after the quantifier.",
                "In general, $\\forall x \\psi$ is logically equivalent to $\\neg\\exists x\\neg \\psi$. This means that any sentence which can be symbolized with a universal quantifier can be symbolized with an existential quantifier, and vice versa. One translation might seem more natural than the other, but there is no logical difference in translating with one quantifier rather than the other. For some sentences, it will simply be a matter of taste.",
                "Sentence \ref{q.en} is most naturally paraphrased as, 'There is some $x$ such that $x$ is not happy.' This becomes $\\exists x \\neg Hx$. Equivalently, we could write $\\neg\\forall x Hx$",
                "The last sentence is most naturally translated as $\\neg\\forall xHx$. This is logically equivalent to 'someone isn't happy' and so could also be translated as $\\exists x \\neg Hx$.",
                "Although we have two quantifiers in PL, we could have an equivalent formal language with only one quantifier. We could proceed with only the universal quantifier, for instance, and treat the existential quantifier as a notational convention. We use square brackets [ ] to make some sentences more readable, but we know that these are really just parentheses ( ). In the same way, we could write '$\\exists x$' knowing that this is just shorthand for '$\\neg \\forall x \\neg$.' There is a choice between making logic formally simple and making it expressively simple. With PL, we opt for expressive simplicity. Both $\\forall$ and $\\exists$ will be symbols of PL.",
                "<h3>Domain of Discourse</h3>",
                "Given the symbolization key we have been using, $\\forall xHx$ means 'Everyone is happy.' Who is included in this everyone? When we use sentences like this in English, we usually do not mean everyone now alive on the Earth. We certainly do not mean everyone who was ever alive or who will ever live. We mean something more modest: everyone in the building, everyone in the class, or everyone in the room.",
                "In order to eliminate this ambiguity, we will need to specify a domain of discourse---abbreviated UD. UD here is short for either 'universe of discourse', or 'universal domain', which are just different names for the domain of discourse. The UD is the set of things that we are talking about. So if we want to talk about people in Chicago, we define the UD to be people in the Chicago. We write this at the beginning of the symbolization key, like this: 'UD: people in Chicago'.",

                "The quantifiers range over the universe of discourse. Given this UD, $\\forall x$ means 'Everyone in Chicago' and $\\exists x$ means 'Someone in Chicago.' Each constant names some member of the UD, so we can only use this UD with the symbolization key above if Donald, Gregor, and Marybeth are all in Chicago. If we want to talk about people in places besides Chicago, then we need to include those people in the UD.",
                "In PL, the UD must be non-empty; that is, it must include at least one thing. It is possible to construct formal languages that allow for empty UDs, but this introduces complications.",
                "Even allowing for a UD with just one member can produce some strange results. Suppose we have this as a symbolization key:"
                ]
              },
              {

                  "type":"symbolkey",
                  "key":[
                    ["$UD$", "the Eiffel Tower"],
                    ["$Px$","x is in Paris."]
                  ]
                },
                {
                  "type":"p",
                  "substance":[
                    "The sentence $\\forall x Px$ might be paraphrased in English as 'Everything is in Paris.' Yet that would be misleading. It means that everything in the domain is in Paris. This UD contains only the Eiffel Tower, so with this symbolization key $\\forall x Px$ just means that the Eiffel Tower is in Paris."
                  ]
                }
        ]
      }
  },
  "2":{
    "1":{
      "chapterName": "Model Semantics for PL",
      "chapterNum": "2",
      "chapterDescription": "In this chapter, we learn about how to use models to evaluate the truth values of PL sentences. " ,

      "title":"Some intuition about model semantics",
      "content":[
        {
          "type":"ps",
          "substance":[

            "Consider the sentence to the left below. It is clear that they are <i>about</i> the circles to the right, in the sense that, the meaning - the truth value - of each sentence is contingent upon how the circles are arranged: if we change the colors of the circles, some sentences originally truth could become false. For instance, if some of the circles were blue, the statement 'every circle is black' would end up false. You can experiment with this by clicking on each circle, which changes its color, and the truth values of the sentences will reflect the updated model.",
            "Thus, each combination of the circles is one possible <i>model</i> which provides the necessary information on how to interpret the sentences. This is the basic intuition about model semantics - we interpret PL sentence in light of the way things within a domain of discourse, which could be everyone in the world, all real numbers, or circles below. Model semantics captures this by using set theory, as a precise way of expressing the existence of objects and their properties. "
          ]
        },
        {
          "type":"important",
          "eventId":"modelballs",
          "substance":["Reading exercise: change the model in a way such that the resultant truth values are in this order: false, false, false, true, false, false, true, true"]
        }
        ,{
          "type":"jsEvent",
          "eventId":"intuitivemodel"
        }
      ]
    },
    "2":{
      "title":"Basic models",
      "content":[
              {
                    "type": "p",
                    "substance": [
                      "In module 1 we developed the truth table system, a semantic method for evaluating sentences and arguments in SL. The method was called semantic, because it involved establishing meanings(truth vales) for all the non-logical parts of a sentence, in this case, the sentence letters. These were called non-logical because their meaning was not fixed by the rules of SL. The logical part of the language was the system of connectives and parentheses. As it turned out, the logical parts of our language were truth functional: the meaning of the larger sentences built up with the connectives and parentheses was simply a function of the truth of the smaller parts. ",
                      "Because the system of sentential connectives and parentheses is truth functional, our semantic system only needed to look at one aspect of the meaning of the sentence letters, their truth value. Thus an interpretation of a sentence in SL simply turned out to be a truth assignment on the sentence letters. That's why you spent module 1 merrily writing Ts and Fs under sentence letters. Each little row of Ts and Fs represented one way of assigning meaning to a sentence or argument, and all the little rows in the truth table represented all the possible ways of assigning meaning to the sentence or argument (at least as far as truth was concerned.) Here we are going to develop similar methods for PL. Because PL is a more complicated system than SL, developing semantics for PL will be much more complicated, and there will be greater limitations for what we can do with these methods.",
                      "The first thing we need to do is to find an equivalent in PL of a little row of Ts and Fs beneath a sentence in SL. We called this little row of Ts and Fs an interpretation, because it gave one aspect of the meaning of the parts of the sentence, namely their truth values. To come up with an interpretation of a sentence in PL, we will need to look at more than the truth or falsity of sentences, though. We have, after all, broken open the atomic sentence to look at its subatomic parts, and now we will need to assign meaning to these parts.",
                      "The way to start is to look at the symbolization keys we created when we were translating sentences in and out of PL. The symbolization key contained a universe of discourse (UD), a meaning for each predicate, and an object picked out by each term. For example:"]
                },{

                    "type": "symbolkey",
                    "key": [
                      ["$UD$"," comic book characters"],
                      [  "$Fx$"," x fights crime"],
                        ["$b$"," Batman"],
                        ["$w$"," Bruce Wayne"]
                    ]
                },
                {
                      "type": "p",
                      "substance": ["Given this symbolization key, we can translate sentences like this"]
                  },{

                      "type": "symbolkey",
                      "key": [
                        ["$Fb$"," Batman fights crime"],
                        [  "$Fw$"," Bruce Wayne fights crime"],
                          ["$Fb \\to Fw$","If Batman fights crime, then Bruce Wayne fights crime"]
                      ]
                  },
                  {
                    "type":"p",
                    "substance":["This symbolization key, along with some basic knowledge of superhero stories, gives us enough information to figure out that the sentence Fb is true. (Notice that the sentence Fb is not true just because of the interpretation. The way we interpret the sentence, plus the way the world is, makes the sentence true.)",

                        "This is the information we need to develop an interpretation of sentences in PL. We are not just assigning truth values anymore. We need to get deeper into meaning here, and look at the reference of the parts of the sentence. Reference is an aspect of meaning that deals with the way bits of language pick out or identify objects in the real world. For our purposes the real world is the universe of discourse, the set of objects we are talking about. To explain how a singular term like b refers, we need only point out the member of the UD it refers to, in this case, Batman. In more technical terms, Batman is the referent of B. For our purposes it is enough to define a referent like this: the referent of a term in PL is the unique object picked out by that term. ",

                        "(Notice that here to explain what b refers to, I have been forced to simply use another singular term in another language, the name 'Batman.' To really pick out the object referred to, I would need to draw your attention to something in the actual world, for instance by holding up a comic book and pointing at the character on the cover.)", "We want to use similar methods to talk about the meaning of predicates. To do this we will talk about the extension of a predicate. The extension of a predicate is the set of objects in the UD that the predicate applies to. So if b is in the extension of the predicate F then the sentence Fb is true.",

                        "(Identifying the extension of a predicate like F again forces us to rely on another language, English. We can say that the extension of F includes Batman, Superman, Green Lantern, etc. The situation is worse because F has an indefinitely large extension, so we have relied on the English predicate 'fights crime' to describe it.)",

                        "This means that we are able to talk about the meaning of sentences in PL entirely in terms of sets. We use curly brackets { and } to denote sets. The members of the set can be listed in any order, separated by commas. The fact that sets can be in any order is important, because it means that {foo, bar} and {bar, foo} are the same set. It is possible to have a set with no members in it. This is called the define{empty set}. The empty set is sometimes written as {}, but usually it is written as the single symbol $\\emptyset$.",

                        "We are now able to give the equivalent of a line in a truth table for PL. An interpretation in PL will be called a model. A model of sentences or arguments in PL consists of a set that is the universe of discourse, individual members of that set that are the referents of the singular terms in the sentences or arguments, and subsets of the universe of discourse which are the extensions of the predicates used in the sentences or arguments. To see how this works imagine I have a bunch of sentences in PL, which include the predicate H and the singular term d. Now consider this symbolization key:"
                    ]
                  },
                  {


                      "type":"symbolkey",
                      "key":[
                          ["UD","People who were in the band Pink Floyd"],
                          ["Gx","x is a guitar player."]
                      ]

                  },
                  {
                    "type": "p",
                    "substance": ["What is the model that corresponds to this interpretation? There were officially five people who were in Pink Floyd over the years, so the UD will have five members: Syd Barrett, David Gilmour, Nick Mason, Roger Waters, and Rick Wright. Syd Barrett and David Gilmour were the official guiar players of the band. The result is this model:"]
                },
                {


                    "type":"symbolkey",
                    "key":[
                        ["UD","{Syd Barrett, David Gilmour, Nick Mason, Roger Waters, Rick Wright}"],
                        ["G","{Syd Barrett, David Gilmour}"],
                        ["b", "Syd Barrett"],
                        ["g","David Gilmour"],
                        ["m","Nick Mason"]
                    ]

                },
                {
                    "type": "p",
                    "substance": ["You do not need to know anything about Pink Floyd in order to evaluate whether sentences are true or false in this model. Gb is true, since the referent of b (Barret) is in the extension of G. The same for $Gg$, but $Gm$ is false, since Mason is not in the extension of G. Both $\\exists x Gx$ and $\\exists x \\neg Gx$ are true, since there is at least one member of the UD that is in the extension of G and at least one member that is not in the extension of G. In this way, the model captures all of the formal significance of the interpretation."]
                }
      ]
    },
    "4": {
            "title": "Models for multiplace predicates",
            "content": {
                "a": {
                    "type": "p",
                    "substance": ["Now consider this interpretation:"]
                },
                "b": {
                    "type": "symbolkey",
                    "key": [["UD", "whole numbers less than 10"], ["Ex", "x is even."], ["Nx", "x is negative."], ["Lxy", "x is less than y."], ["Txyz", "x times y equals z "]]
                },
                "c": {
                    "type": "p",
                    "substance": ["The extension of a one-place predicate like E or B is just the subset of the UD of which the predicate is true. The extension of E is the subset {2,4,6,8}. There are many even numbers besides these four, but these are the only members of the UD that are even. There are no negative numbers in the UD, so $N$ has an empty extension; i.e. extension{N}=$\\emptyset$.",

                        "The extension of a two-place predicate like L is somewhat vexing. It seems as if the extension of L ought to contain 1, since 1 is less than all the other numbers; it ought to contain 2, since 2 is less than all of the other numbers besides 1; and so on. Every member of the UD besides 9 is less than some member of the UD. What would happen if we just wrote extension{L}={1,2,3,4,5,6,7,8}?",

                        "The problem is that sets can be written in any order, so this would be the same as writing extension{L}={8,7,6,5,4,3,2,1}. This does not tell us which of the members of the set are less than which other members.",

                        "We need some way of showing that 1 is less than 8 but that 8 is not less than 1. The solution is to have the extension of L consist of pairs of numbers. An ordered pair is like a set with two members, except that the order does matter. We write ordered pairs with angle brackets < and >. The ordered pair <foo, bar is different than the ordered pair <bar, foo>. The extension of L is a collection of ordered pairs, all of the pairs of numbers in the UD such that the first number is less than the second. Writing this out completely:"
                    ]
                },
                "g": {
                    "type": "unorderedList",
                    "substance": ["{<1,2>,<1,3>....<2,3>,<2,4>,....<3,4>, <3,5>,...<8,9>}"]
                },
                "h": {
                    "type": "p",
                    "substance": ["Three-place predicates will work similarly; the extension of a three-place predicate is a set of ordered triples where the predicate is true of those three thing in that order. So the extension of T in this model will contain ordered triples like <2,4,8>, because $2\\times 4 = 8$.",
                        "Generally, the extension of an n-place predicate is a set of all ordered n-tuples $\\{<a_1, a_2,\\ldots, a_n>\\}$ such that $a_1..a_n$ are members of the UD and the predicate is true of $a_1..a_n$in that order."
                    ]
                }
            }
        },
        "5":{
          "title":"Using model to prove logical properties",
          "content":[
            {
                    "type": "ps",
                    "substance": ["Working with models is in some ways like working with truth tables and in some ways not. With truth tables, we could conclusively show that a sentence was a tautology or a contradiction, because the truth table would always have a finite number of lines. We cannot, however, use models to show that a sentence is a tautology or a contradiction, because there are infinitely many ways to model a sentence, and and no single way to talk about all of them, the way we talked about all the lines in a truth table. One thing we can do is show conclusively that a sentence is neither a tautology nor a contradiction, and is instead contingent. A contingent sentence will have at least one model where it is false and one model where it is true.",

                        "We will use the double turnstile symbol to represent the notion of <i>semantic entailment</i>. '$\\mathcal{A} \\vDash \\mathcal{B}$' means that an argument from $\\mathcal{A}$ to $\\mathcal{B}$ is semantically valid.  $\\vDash \\mathcal{A}$ means that $\\mathcal{A}$ is a semantic tautology. $\\mathcal{A} \\equiv \\mathcal{B}$ means $\\mathcal{A} $ and $\\mathcal{B} $ are semantically equivalent. ",

                        "In our discussion of SL semantics, we stipulated semantic definitions for various logical concepts in SL that matched our truth table method for determining these concepts. So a sentence was said to be a tautology in SL if the column under its main connective contained only Ts. This was an alternative to saying the the truth table method was an imprecise way of getting at the ordinary language versions of these concepts. We will do something similar for the semantic definitions of logical notions in PL. "
                    ]
                },
                {
                    "type": "niceList",
                    "substance": [
                        "A semantic tautology in PL is a sentence $\\mathcal{A}$ that is true in every model; i.e.,  $\\vDash \\mathcal{A}$.",

                        "A semantic contradiction in PL is a sentence $\\mathcal{A}$ that is false in every model; i.e., $\\vDash \\neg \\mathcal{A}$.",

                        "A sentence is semantically contingent in PL if and only if it is neither a tautology nor a contradiction.",

                        "Two sentences $\\mathcal{A}$ and $\\mathcal{B}$ are semantically equivalent in PL if and only if they have the same truth value in every model.",

                        "The set ${\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3,...}$ is semantically consistent in PL if and only if there is at least one model in which all of the sentences are true. The set is semantically inconsistent in PL if and if only there is no such model.",

                        "An argument  $\\mathcal{P}_1, \\mathcal{P}_2, ... \\therefore \\mathcal{C}$  is semantically valid in PL if and only if there is no model in which all of the premises are true and the conclusion is false; i.e., ${\\{\\mathcal{P}_1,\\mathcal{P}_2,...}\\}\\vDash\\mathcal{C}$. It is semantically invalid in PL otherwise."
                    ]
                },
                {
                  "type":"ps",
                  "substance":[
                    "<h3>Contingency</h3>",
                    "Suppose we want to show that \\(\\forall xAxx \\to Bd\\) is not a tautology. This requires showing that the sentence is not true in every model; i.e., that it is false in some model. If we can provide just one model in which the sentence false, then we will have shown that the sentence is not a tautology.",

                        "What would such a model look like? In order for \\(\\forall xAxx \\to \\neg Bd\\) to be false, the antecedent \\(\\forall x Axx\\) must be true, and the consequent \\(Bd\\) must be false.",

                        "To construct such a model, we start with a UD. It will be easier to specify extensions for predicates if we have a small UD, so start with a UD that has just one member. Formally, this single member might be anything, so let's just call it \\(\\alpha.\\) ",

                        "We want \\(\\forall x Axx\\) to be true, so we want all members of the UD to be paired with themselves in the extension of \\(A\\); this means that the extension of \\(A\\) must be {\\(<\\alpha,\\alpha>\\)}.",

                        "We want \\(Bd\\) to be false, so the referent of \\(d\\) must not be in the extension of \\(B\\). We give \\(B\\) an empty extension.",

                        "Since \\(\\alpha\\) is the only member of the UD, it must be the referent of \\(d\\). The model we have constructed looks like this:"
                  ]
                },
                {
                   "type": "symbolkey",
                   "key": [
                       ["$UD$","$\\{\\alpha\\}$"],
                      [ "$A$","$\\{<\\alpha, \\alpha>\\}$"],
                       ["$B$","$\\emptyset$"],
                       ["$d$","$\\alpha$"]
                   ]
               },
               {
                 "type":"p",
                 "substance":[
                   "Strictly speaking, a model specifies an extension for every predicate of PL and a referent for every constant. As such, it is generally impossible to write down a complete model. That would require writing down infinitely many extensions and infinitely many referents. However, we do not need to consider every predicate in order to show that there are models in which \\(\\forall xAxx \\to Bd\\) is false. Predicates like \\(H\\) and constants like \\(f_{13}\\) make no difference to the truth or falsity of this sentence. It is enough to specify extensions for \\(A\\) and \\(B\\) and a referent for \\(d\\), as we have done. This provides a partial model in which the sentence is false.",
                        "Perhaps you are wondering: What is \\(\\alpha\\)? What does the predicate \\(A\\) mean in English? The partial model could correspond to an interpretation like this one:"
                 ]
               },
               {
                  "type": "symbolkey",
                  "key": [
                      ["$UD$","$\\{ Paris \\}$"],
                     [ "$Axy$","x is in the same country as y"],
                      ["d","The capital of France"]
                  ]
              },
              {
                "type":"p",
                "substance":[
                  "However, we don't have to say that this model corresponds to any particular interpretation of the sentence in English in order to know that the sentence \\(\\forall xAxx \\to Bd\\)  is not a tautology. We could have made our one-object universe of discourse contain only Mahatma Gandhi, or a pebble on a beach in Africa, or the number 2. As long as the predicate and terms were given the right reference, the sentence would come out false. Thus in the future we can evalaute sentences and arguments using UDs with arbitrarily named elements, like \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), etc. ",

                        "We use the same method to show that \\(\\forall xAxx \\to Bd\\) is not a contradiction. We need only specify a model in which \\(\\forall xAxx \\to Bd\\) is true; i.e., a model in which either \\(\\forall x Axx\\) is false or \\(Bd\\) is true. Here is one such partial model:"
                ]
              },
              {
                 "type": "symbolkey",
                 "key": [
                     ["$UD$","$\\{ \\alpha \\}$"],
                    [ "$A$","$\\{ (\\alpha,\\alpha) \\}$"],
                     ["d","$\\alpha$"]
                 ]
             },
             {
               "type":"ps",
               "substance":[
                 "We have now shown that \\(\\forall xAxx \\to Bd\\) is neither a tautology nor a contradiction. By the definition of 'contingent in PL,' this means that \\(\\forall xAxx \\to Bd\\) is contingent. In general, showing that a sentence is contingent will require two models: one in which the sentence is true and another in which the sentence is false.",
                       "Notice, however, that we cannot show that a sentence actually is a tautology or a contradiction using one or two models this way. For a sentence to be a tautology, it must be true in every possible model. Similarly, if a sentence is a contradiction, it is false in all possible models. But there are infinitely many possible models for any sentence, and we don't have any tools in this text that will let us reason about all of them at once. ",
                    "<h3>Non-equivalence</h3>",
                    "Suppose we want to show that \\(\\forall x Sx\\) and \\(\\exists x Sx\\) are not logically equivalent. We need to construct a model in which the two sentences have different truth values; we want one of them to be true and the other to be false. We start by specifying a UD. Again, we make the UD small so that we can specify extensions easily. We will need at least two members. Let the UD be {\\(\\alpha\\), \\(\\beta\\)}. (If we chose a UD with only one member, the two sentences would end up with the same truth value. In order to see why, try constructing some partial models with one-member UDs.)",

                        "We can make \\(\\exists x Sx\\) true by including something in the extension of \\(S\\), and we can make \\(\\forall x Sx\\) false by leaving something out of the extension of \\(S\\). It does not matter which one we include and which one we leave out. Making \\(\\alpha\\) the only \\(S\\), we get a partial model that looks like this:"
               ]
             },
             {
               "type":"symbolkey",
               "key":[
                 ["$UD$","$\\{\\alpha, \\beta\\}$"],
                 ["$S$","$\\alpha$"]
               ]
             },
             {
               "type":"textInput","eventId":"pl-2-txt1","substance":["Can we use models to prove that two PL sentences are logically equivalent? Why or why not?"]
             },
             {
               "type":"ps",
               "substance":[
                 "<h3>Consistency</h3>",
                 "Suppose I wanted to show that the set of sentences \\(\\{\\exists x Fx, \\exists x \\neg Fx, \\forall x Gx\\}\\) is consistent. For this to be the case, we need at least one model where all three sentences are true. In this case that means having one object in our UD that is \\(F\\) and one that is not \\(F\\), and we need both of them to be \\(G\\). This would do the trick."
               ]
             },
             {
               "type":"symbolkey",
               "key":[
                 ["$UD$","$\\{\\alpha, \\beta\\}$"],
                 ["$F$","$\\alpha$"],
                 ["$G$","$\\{\\alpha, \\beta\\}$"]
               ]
             },
             {
               "type":"textInput","eventId":"pl-2-txt2","substance":["Can we use models to prove that two PL sentences are inconsistent? Why or why not? Make sure your answer is compatible with your answer for proving logical equivalence."]
             },
             {
               "type":"ps",
               "substance":[
                 "<h3>Invalidity</h3>",
                 "Consider this invalid argument: $((Rc \\wedge Kc) \\wedge Tc) \\therefore Tc \\wedge Hc$",
                 "In order to show that it is invalid, we need to show that there is some model in which the premises are true and the conclusion is false. We can construct such a model deliberately. Here is one way to do it:"
               ]
             },
             {
               "type":"symbolkey",
               "key":[
                 ["$UD$","$\\{\\alpha\\}$"],
                 ["$T$","$\\{\\alpha\\}$"],
                 ["$K$","$\\{\\alpha\\}$"],
                 ["$H$","{}"],
                 ["$R$","$\\{\\alpha\\}$"],
                 ["$c$","$\\alpha$"]


               ]
             },
             {
               "type":"textInput","eventId":"pl-2-txt3","substance":["Can we use models to prove that an argument is valid? Why or why not? Make sure your answer is compatible with your previous answers."]
             },
             {
                 "type": "category",
                 "title": "Reading exercise: Interpretation",
                 "instruction": "For each of the sentences below, determine whether it is true or false. Use the following model: $$UD:\\{Bart, Cathy\\}$$ $$A:\\{Bart, Cathy\\}$$ $$ B: \\{Bart\\} $$ $$ N: \\{\\}$$ $$R:\\{(Bart,Cathy)\\}$$ $$b: Bart$$ $$ c: Cathy $$Once done, press confirm. NOTE: There is no penalty for multiple attempts but you must correctly categorize each sentence to get credit!",
                 "eventId": "pl-2-cat"
             }


          ]
        }

  }
}
